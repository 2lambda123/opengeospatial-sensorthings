[appendix,obligation="normative"]
== Conformance Class Abstract Test Suite

This normative section defines the STAplus 1.0 Conformance Class tests.

[NOTE]
A STAplus compliant implementation must also be compliant with the SensorThings API conformance as defined in <<OGC15-078r6>>, respectively <<OGC18-088>>.

=== STAplus *Core* Conformance Class Tests


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/common-control-information
target:: {identifier}/conf/core

target:: {identifier}/req/common-control-information

test-purpose:: To verify that the common control information is available as defined in the requirement.
test-method-type:: Manually Inspect
test-method:: Inspect the full JSON object of the entity sets (__i.e.__, without $select) to identify, if each entity has the common control information defined in Requirement Class <<common-control-information>> and the service sends appropriate responses as defined in this Standard.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/entities
inherit:: {identifier}/conf/core/common-control-information
target:: {identifier}/conf/core

target:: {identifier}/req/party/properties
target:: {identifier}/req/party/relations

target:: {identifier}/req/license/properties
target:: {identifier}/req/license/relations

target:: {identifier}/req/group/properties
target:: {identifier}/req/group/relations

target:: {identifier}/req/relation/properties
target:: {identifier}/req/relation/relations

target:: {identifier}/req/campaign/properties
target:: {identifier}/req/campaign/relations

test-purpose:: Verify that each STAplus entity has the mandatory properties and mandatory relations as defined in this Standard.
test-method-type:: Manually Inspect
test-method:: Evaluate for each STAplus entity:

part:: Inspect the full JSON object of the entity sets (__i.e.__, without $select) to identify, if each entity has the mandatory properties defined in the corresponding requirement.

part:: Inspect the full JSON object of each entity set (__i.e.__, without using the $select query option) to identify, if each entity has the mandatory relations (__i.e.__, @iot.navigationLink) defined in the corresponding requirement.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/read
inherit:: {identifier}/conf/core/entities
target:: {identifier}/conf/core

target:: {identifier}/req/read/entity


test-purpose:: Verify that the implementation supports reading STAplus entities via HTTP GET.
test-method-type:: Manually Inspect
test-method:: Evaluate that the implementation accepts a Sensor Things API compliant HTTP Get request to the STAplus entities:

part:: Construct a URL to the `Party` entity and verify the response.
part:: Construct a URL to the `License` entity and verify the response.
part:: Construct a URL to the `ObservationGroup` entity and verify the response.
part:: Construct a URL to the `Relation` entity and verify the response.
part:: Construct a URL to the `Campaign` entity and verify the response.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/default-crs/crs-definition
target:: {identifier}/conf/core

target:: {identifier}/req/default-crs/crs-definition


test-purpose:: Verify that the implementation supports and uses the default-CRS.
test-method:: Evaluate that the implementation uses the default-CRS.

part:: Construct a `Location` entity that contains a `Location` property whose geometry is encoded using the default-CRS and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS.
part:: Construct a `FeatureOfInterest` entity that contains a `Feature` property whose geometry is encoded using the default-CRS and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/default-crs/axis-order
target:: {identifier}/conf/core

target:: {identifier}/req/default-crs/axis-order


test-purpose:: Verify that the implementation supports and uses the default axis-order.
test-method:: Evaluate that the implementation uses the default axis-order.

part:: Construct a `Location` entity that contains a `location` property whose geometry is encoded using the default axis-order and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS.
part:: Construct a `FeatureOfInterest` entity that contains a `feature` property whose geometry is encoded using the default axis-order and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/default-crs/media-type
target:: {identifier}/conf/core

target:: {identifier}/req/default-crs/media-type


test-purpose:: Verify that the implementation supports and uses the default media-type.
test-method:: Evaluate that the implementation uses the default media-type.

part:: Construct a `Location` entity that contains a `location` property whose geometry is encoded using the default-CRS and axis-order where the `encodingType` property's value is `application/geo+json` and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS and axis-order.
part:: Construct a `FeatureOfInterest` entity that contains a `feature` property whose geometry is encoded using the default-CRS and axis-order where the `encodingType` property's value is `application/geo+json` and check that the implementation is processing the geometry accordingly and that the geometry data is stored using the default-CRS and axis-order.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/core/default-crs/processing
target:: {identifier}/conf/core

target:: {identifier}/req/default-crs/processing


test-purpose:: Verify that the implementation stores geometry that is encoded in the default-CRS and axis-order without processing.
test-method:: Evaluate that the implementation stores geometry that is encoded in the default-CRS and axis-order without processing.

part:: Construct a `Location` entity that contains a `location` property whose geometry is encoded using the default-CRS and axis-order where the `encodingType` property's value is `application/geo+json` and check that the implementation is stores the geometry data without processing.
part:: Construct a `FeatureOfInterest` entity that contains a `feature` property whose geometry is encoded using the default-CRS and axis-order where the `encodingType` property's value is `application/geo+json` and check that the implementation is storing the geometry data without a CRS transformation.
====








=== STAplus *Create* Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/create/http
target:: {identifier}/conf/create

target:: {identifier}/req/create/entity
target:: {identifier}/req/create/link-to-existing-entities
target:: {identifier}/req/create/deep-insert
target:: {identifier}/req/create/deep-insert-status-code


test-purpose:: To verify that the service implementation supports the creation of entities as defined in this Standard.
test-method:: For each STAplus entity:

part:: Create an entity instance by following the integrity constraints and creating the related entities with a single request (__i.e.__, deep insert), check if the entity instance is successfully created and the implementation responds as defined in this Standard.

part:: Create an entity instance and its related entities with a deep insert request that does not conform to the Standard (e.g., missing a mandatory property), check if the service fails the request without creating any entity within the deep insert request and responds the appropriate HTTP status code.


part:: Issue an entity creation request that does not follow the integrity constraints with deep insert, check if the service fails the request without creating any entity within the deep insert request and responds the appropriate HTTP status code.


part:: Create an entity instance by linking to existing entities with a single request, check if the server responds as defined in this Standard.


part:: Create an entity instance that does not follow the integrity constraints by linking to existing entities with a single request, check if the server responds as defined in this Standard.
====


=== STAplus *Update* Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/update/put
target:: {identifier}/conf/update

target:: {identifier}/req/update/entity
target:: {identifier}/req/update/entity-put


test-purpose:: To verify that the service implementation supports the update of entities as defined in this Standard.
test-method:: For each STAplus entity:

part:: Send an update request with HTTP PATCH and check if the service responds as defined.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/update/patch
target:: {identifier}/conf/update

target:: {identifier}/req/update/entity
target:: {identifier}/req/update/entity-jsonpatch


test-purpose:: To verify that the service implementation supports the update of entities as defined in this Standard.
test-method:: For each STAplus entity:

part:: Send an update request with PATCH, check (1) if the properties provided in the payload corresponding to updatable properties replace the value of the corresponding property in the entity and (2) if the missing properties of the containing entity or complex property are not directly altered.

part:: Send an update request with PATCH that contains related entities as inline content, check if the service fails the request and returns appropriate HTTP status code.

part:: Send an update request with PATCH that contains binding information for navigation properties, check if the service updates the navigationLink accordingly.
====



=== STAplus *Delete* Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/delete/entity
target:: {identifier}/conf/delete

target:: {identifier}/req/delete/entity


test-purpose:: To verify that the service implementation supports the deletion of entities as defined.
test-method:: For each STAplus entity:

part:: Delete an entity instance, and check if the service responds as defined.
====



=== STAplus *Authentication* Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/authentication/id
target:: {identifier}/conf/authentication

target:: {identifier}/req/authentication/id


test-purpose:: To verify that the user's identifier is permanent and unique.
test-method:: Verify the following:

part:: Compare the user identifier after repeated login of the same user and verify that the identifier is identical.
part:: Compare the user identifier for different users and verify that the identifiers are different.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/authentication/id-create
target:: {identifier}/conf/core

target:: {identifier}/req/authentication/id-create


test-purpose:: To verify that the identifier value stored in `Party/authId` is the value set by the authentication.
test-method:: For a non-existing `Party` entity:

part:: Submit a HTTP POST request to create a `Party` entity where the `authId` is not set.
part:: Observe the response to find the location URI for the created `Party` entity.
part:: Issue a HTTP GET request to the location URI and verify that the `Party/authId` is set with the unique identifier that represents the user.

part:: Submit a HTTP POST request to create a `Party` entity where the `authId` is set with some value.
part:: Observe the response status code and verify it is 400.

====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/authentication/id-read
target:: {identifier}/conf/authentication

target:: {identifier}/req/authentication/id-read


test-purpose:: To verify that the `Party/authId` is exposed in a response.
test-method:: Verify that response from any `Party` entity includes the `authId`:

part:: Construct a HTTP GET request to some `Party` entity and verify that the `authId` is contained in the response.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/authentication/id-update
target:: {identifier}/conf/authentication

target:: {identifier}/req/authentication/id-update

test-purpose:: To verify that a user can *not* update the identifier stored in `Party/authId`.
test-method:: Verify that changing the `authId` is not possible for the user itself:

part:: Have the user authenticate and identify the corresponding `Party`.
part:: Construct a HTTP PATCH request to that **same** `Party` entity where the `authId` is set with some value.
part:: Issue a HTTP GET request to that `Party` and verify that the value of the `authId` has not changed.

test-method:: Verify that changing the `authId` is not possible for any other user:

part:: Have the user authenticate and identify the corresponding `Party`.
part:: Construct a HTTP PATCH request to *another* existing `Party` entity where the `authId` is set with some value.
part:: Issue a HTTP GET request to that other `Party` and verify that the value of the `authId` has not changed.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/authentication/id-delete
target:: {identifier}/conf/authentication

target:: {identifier}/req/authentication/id-delete

test-purpose:: To verify that a user can *not* delete the identifier stored in `Party/authId`.
test-method:: Verify that deleting the `authId` is not possible for the user itself:

part:: Have the user authenticate and identify the corresponding `Party`.
part:: Construct a HTTP DELETE request to that `Party` entity.
part:: Issue a HTTP GET request to that `Party` and verify that the entity still exists.

test-method:: Verify that deleting the `authId` is not possible for any other user:

part:: Have the user authenticate and identify the corresponding `Party`.
part:: Construct a HTTP DELETE request to *another* existing `Party`.
part:: Issue a HTTP GET request to that other `Party` and verify that the entity still exists.
====


=== STAplus *Business Logic* Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/business-logic/definition
target:: {identifier}/conf/business-logic

target:: {identifier}/req/business-logic/definition

test-purpose:: To verify that the description of the business logic is human readable and in English.
test-method:: Verify that the HTML page for the business logic is in English language.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/business-logic/location
target:: {identifier}/conf/business-logic

target:: {identifier}/req/business-logic/location

test-purpose:: To verify that the business logic is available from the provided URL.
test-method:: On the service root URI, find the JSON object with name `{identifier}/conf/business-logic` and follow the link provided in the `href` property. Verify that the loaded HTML page contains the description of the business logic.
====




=== STAplus *Geometry FG* Conformance Class Tests

NOTE: These Conformance Class Tests remain informative until <<FG>> is an adopted OGC Standard.

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg//media-type
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/media-type

test-purpose:: To verify that the implementation accepts media-type for Geometry-FG.
test-method:: Verify that the implementation supports the use of the media-type for Geometry-FG.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg/default-crs
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/default-crs

test-purpose:: To verify that the default-CRS is used for processing geometry data from `Feature` and `Location`.
test-method:: Verify that the implementation applies the default-CRS advertised in the conformance page to the geometry data from `Feature` and `Location`.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg/supported-crs
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/supported-crs

test-purpose:: To verify that all CRS, advertised as supported in the conformance page are accepted.
test-method:: Verify that the implementation accepts geometry encodings for `Feature` and `Location`. For each supported CRS:

part:: Construct a geometry and create a `Location` and `FeatureOfInterest` entity. Verify that the geometry data is accepted by the implementation.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg/crs-error
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/crs-error

test-purpose:: To verify that no additional CRS, as advertised in the conformance page, 
are accepted.
test-method:: Verify that the implementation *does not* accept geometry encodings for `Feature` and `Location` that are not listed as supported. For a CRS *not* listed as supported:

part:: Construct a geometry and create a `Location` and `FeatureOfInterest` entity. Verify that the geometry data is *rejected* by the implementation.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg/processing
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/processing

test-purpose:: To verify that a geometry not encoded in the default-CRS is transformed before storage.
test-method:: Verify that the implementation accepts geometry encodings for `Feature` and `Location` that use a supported CRS:

part:: Construct a geometry and create a `Location` and `FeatureOfInterest` entity. Verify that the geometry data is accepted and transformed to the default-CRS before processed and stored by the implementation.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-fg/out
target:: {identifier}/conf/geometry-fg

target:: {identifier}/req/geometry-fg/out

test-purpose:: To verify that a geometry included in a response is encoded in the default-CRS.
test-method:: Verify that the geometry data for a `Feature` and `Location` is using default-CRS, independent from the geometry CRS used with the creation or updating of the entity.
====


=== STAplus *Geometry WKT* Conformance Class Tests


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/media-type
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/media-type

test-purpose:: To verify that the implementation accepts media-type for WKT.
test-method:: Verify that the implementation supports the use of the media-type for WKT.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/crs-definition
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/crs-definition

test-purpose:: To verify that the implementation accepts CRS definition provided in the associated property.
test-method:: Verify that the implementation supports the use of the CRS property.

part:: Construct a WKT geometry in a CRS different from the `default-crs`.
part:: Set the `crs` property to the CRS identifier.
part:: Verify that the implementation processes the geometry honoring the CRS identified by the `crs` value.
part:: Set the `srid` property to the CRS identifier number.
part:: Verify that the implementation processes the geometry honoring the CRS identified by the `srid` value.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/default-crs
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/default-crs

test-purpose:: To verify that the default-CRS is used for processing geometry data from `feature` and `location` property.
test-method:: Verify that the implementation defines and applies the default-CRS to the geometry data from `feature` and `location` property.

part:: Find the JSON object in the `serverSettings` object on the root URI with the name `{identifier}/conf/geometry-wkt` and check the value of the property `default-crs`.
part:: Verify that the `default-crs` is applied to a WKT geometry if no `crs` or `srid` property is used.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/supported-crs
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/supported-crs

test-purpose:: To verify that all supported CRS are accepted.
test-method:: Verify that the implementation accepts geometry encodings for `feature` and `location` properties. For each supported CRS:

part:: Execute test {identifier}/conf/geometry-wkt/crs-definition and verify that the implementation processes the geometry correctly.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/crs-error
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/crs-error

test-purpose:: To verify that only supported CRSs are accepted.
test-method:: Verify that the implementation *does not* accept geometry encodings for `feature` and `location` properties that are not listed as supported. For a CRS *not* listed as supported:

part:: Execute test {identifier}/conf/geometry-wkt/crs-definition and verify that the geometry data is *rejected* by the implementation.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/value
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/value

test-purpose:: To verify that the geometry value, compliant to WKT is accepted as value for the `feature` and `location` property.
test-method:: Verify that the implementation accepts WKT geometry values for `feature` and `location` properties.
====


[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/processing
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/processing

test-purpose:: To verify that a geometry not encoded in the default-CRS is transformed before storage.
test-method:: Verify that the implementation accepts geometry encodings for `Feature` and `Location` that use a supported CRS:

part:: Construct a geometry and create a `Location` and `FeatureOfInterest` entity. Verify that the geometry data in the `location` and `feature` properties is accepted and transformed to the default-CRS before processed and stored by the implementation.
====

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/geometry-wkt/out
target:: {identifier}/conf/geometry-wkt

target:: {identifier}/req/geometry-wkt/out

test-purpose:: To verify that a geometry included in a response is encoded in the default-CRS.
test-method:: Verify that the geometry data for a `feature` and `location` properties is using default-CRS, independent from the geometry CRS used with the creation or updating of the entity.
====


=== STAplus *MQTT Subscribe* STA v1.0 Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/mqtt-subscribe-sta-10/definition
target:: {identifier}/conf/mqtt-subscribe-sta-10
target:: {identifier}/req/mqtt-subscribe-sta-10

test-purpose:: To verify that a client can receive notifications for the updates of a STAplus entity set or an individual entity with MQTT.
test-method:: For each STAplus entity:

part:: Subscribe to an entity set with MQTT Subscribe. Then create a new entity of the subscribed entity set. Check if a complete JSON representation of the newly created entity through MQTT is received.

part:: Subscribe to an entity set with MQTT Subscribe. Then update an existing entity of the subscribed entity set. Check if a complete JSON representation of the updated entity through MQTT is received.

part::  Subscribe to an entity’s property with MQTT Subscribe. Then update the property with PATCH. Check if the JSON object of the updated property is received.

Subscribe to multiple properties of an entity set with MQTT Subscribe. Then create a new entity of the entity set.  Check if a JSON object of the subscribed properties is received.

part:: Subscribe to multiple properties of an entity set with MQTT Subscribe. Then update an existing entity of the entity set with PATCH. Check if a JSON object of the subscribed properties is received.
====

=== STAplus *MQTT Subscribe* STA v1.1 Conformance Class Tests

[conformance_test]
====
[%metadata]
identifier:: {identifier}/conf/mqtt-subscribe-sta-11/definition
target:: {identifier}/conf/mqtt-subscribe-sta-11
target:: {identifier}/req/mqtt-subscribe-sta-11

test-purpose:: To verify that a client can receive notifications for the updates of a STAplus entity set or an individual entity with MQTT.
test-method:: For each STAplus entity:

part:: Subscribe to an entity set with MQTT Subscribe. Then create a new entity of the subscribed entity set. Check if a complete JSON representation of the newly created entity through MQTT is received.

part:: Subscribe to an entity set with MQTT Subscribe. Then update an existing entity of the subscribed entity set. Check if a complete JSON representation of the updated entity through MQTT is received.

part:: Subscribe to an entity’s property with MQTT Subscribe. Then update the property with PATCH. Check if the JSON object of the updated property is received.

Subscribe to multiple properties of an entity set with MQTT Subscribe. Then create a new entity of the entity set.  Check if a JSON object of the subscribed properties is received.

part:: Subscribe to multiple properties of an entity set with MQTT Subscribe. Then update an existing entity of the entity set with PATCH. Check if a JSON object of the subscribed properties is received.
====